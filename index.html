<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M.E.E.T // Grab & Rotate Module</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js & Tween.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: #00f0ff;
            user-select: none;
        }

        /* Sci-Fi UI Elements */
        .glass-panel {
            background: rgba(10, 20, 30, 0.7);
            border: 1px solid rgba(0, 240, 255, 0.3);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
        }

        .btn-jarvis {
            background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.1), transparent);
            border: 1px solid rgba(0, 240, 255, 0.3);
            color: #00f0ff;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 14px 24px;
            font-size: 14px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            cursor: pointer;
        }

        .btn-jarvis:hover {
            background: rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.6);
            border-color: #00f0ff;
        }

        .btn-jarvis.active {
            background: #00f0ff;
            color: #000;
            box-shadow: 0 0 25px #00f0ff;
            font-weight: bold;
        }

        /* Range Slider */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #00f0ff; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px #00f0ff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: rgba(0, 240, 255, 0.3); border-radius: 2px;
        }

        /* Spinner & Video */
        .arc-spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(0, 240, 255, 0.2);
            border-top: 4px solid #00f0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #webcam {
            transform: scaleX(-1);
            filter: sepia(100%) hue-rotate(130deg) saturate(200%) contrast(1.2) brightness(0.8);
            opacity: 0.6;
            width: 100%; height: 100%;
            object-fit: cover;
        }

        #gesture-icon { font-size: 2.5rem; filter: drop-shadow(0 0 10px #00f0ff); }
        
        .arrow-indicator { 
            transition: all 0.2s; opacity: 0.2; color: rgba(0, 240, 255, 0.5);
        }
        .arrow-indicator.active { 
            opacity: 1; text-shadow: 0 0 15px #00f0ff; color: #fff; transform: scale(1.2);
        }
    </style>
</head>
<body class="h-screen w-screen relative overflow-hidden" oncontextmenu="return false;">

    <!-- 3D Canvas -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- Init Screen -->
    <div id="init-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md">
        <div class="arc-spinner mb-8"></div>
        <h1 class="text-5xl font-mono font-bold tracking-widest mb-2 text-cyan-400 drop-shadow-[0_0_15px_rgba(0,240,255,0.8)]">M.E.E.T</h1>
        <p class="font-mono text-cyan-700 text-sm mb-8">TACTILE INTERFACE // MK-85</p>
        <button onclick="initSystem()" class="btn-jarvis text-xl font-bold px-12 py-4">INITIALIZE</button>
        <p id="status-msg" class="text-xs text-gray-500 mt-4 font-mono">Camera access required for hand tracking.</p>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="hidden absolute inset-0 z-10 pointer-events-none p-4 md:p-8 flex flex-col justify-between">
        
        <!-- Header -->
        <header class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-4 rounded-br-2xl border-l-4 border-cyan-400 max-w-xs">
                <h2 class="text-2xl font-bold font-mono tracking-widest">MEET IND.</h2>
                <div class="h-[1px] bg-cyan-900 my-2 w-full"></div>
                <div class="text-xs font-mono text-cyan-300">
                    <span id="fps-stat">60</span> FPS // <span id="particle-stat">3000</span> ENTITIES
                </div>
            </div>
            
            <div class="glass-panel w-48 h-32 border border-cyan-800 relative rounded overflow-hidden">
                <video id="webcam" autoplay playsinline muted></video>
                <div class="absolute top-1 left-1 text-[9px] bg-black/70 px-1 font-mono text-cyan-300 font-bold">OPTICAL SENSORS</div>
                <div class="absolute bottom-2 right-2 w-4 h-4 rounded-full bg-red-500 shadow-[0_0_10px_red]" id="cam-status-dot"></div>
                <div id="no-cam-icon" class="hidden absolute inset-0 flex items-center justify-center bg-black/80 text-cyan-500 font-mono text-xs text-center p-2">
                    MANUAL OVERRIDE<br>MOUSE ENABLED
                </div>
            </div>
        </header>

        <!-- Main Area -->
        <div class="flex-1 flex items-center justify-between mt-8">
            
            <!-- Left Controls -->
            <nav class="flex flex-col gap-4 pointer-events-auto w-64">
                <div class="glass-panel p-4 rounded-lg">
                    <div class="text-[10px] font-mono text-gray-400 mb-2 pl-1 tracking-wider">PROJECTION TEMPLATES</div>
                    <div class="flex flex-col gap-2">
                        <button class="btn-jarvis text-left active" onclick="switchShape('sphere', this)">CORE SPHERE</button>
                        <button class="btn-jarvis text-left" onclick="switchShape('cube', this)">TESSERACT</button>
                        <button class="btn-jarvis text-left" onclick="switchShape('arc', this)">ARC REACTOR</button>
                        <button class="btn-jarvis text-left" onclick="switchShape('helix', this)">DNA HELIX</button>
                        <button class="btn-jarvis text-left text-red-400 border-red-900/50 hover:border-red-500" onclick="switchShape('explode', this)">DETONATE</button>
                    </div>
                </div>

                <!-- Sliders -->
                <div class="glass-panel p-4 rounded-lg flex flex-col gap-4">
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <div class="text-[10px] font-mono text-gray-400 tracking-wider">PARTICLE SIZE</div>
                            <div id="size-val" class="text-[10px] font-mono text-cyan-400">0.30</div>
                        </div>
                        <input type="range" min="0.05" max="1.5" step="0.05" value="0.30" class="w-full" oninput="updateParticleSize(this.value)">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <div class="text-[10px] font-mono text-gray-400 tracking-wider">ZOOM LEVEL</div>
                            <div id="zoom-val" class="text-[10px] font-mono text-cyan-400">35</div>
                        </div>
                        <input id="zoom-slider" type="range" min="10" max="100" step="1" value="35" class="w-full" oninput="updateZoom(this.value)">
                    </div>
                </div>
            </nav>

            <!-- Right Controls -->
            <div class="glass-panel p-6 rounded-l-xl border-r-4 border-cyan-400 w-64 text-right pointer-events-auto">
                <div class="text-[10px] font-mono text-gray-400 mb-4 tracking-widest">COMMAND INTERFACE</div>
                
                <div class="flex flex-col items-end gap-3">
                    <div id="gesture-icon">üñê</div>
                    <div id="gesture-text" class="text-2xl font-bold font-mono text-white">IDLE</div>
                    <div class="text-xs text-cyan-600 font-mono mt-2" id="gesture-desc">Tracking Hand...</div>
                </div>

                <!-- 4-Way Rotation Arrows -->
                <div class="mt-6 border-t border-cyan-900 pt-4 flex flex-col items-center justify-center gap-1 font-mono text-cyan-500 text-xl font-bold">
                    <div id="arrow-up" class="arrow-indicator mb-1">‚ñ≤</div>
                    <div class="flex items-center justify-between w-full px-2">
                        <span id="arrow-left" class="arrow-indicator">‚óÄ</span>
                        <div class="flex flex-col items-center">
                            <span class="text-[10px] text-gray-500 font-normal">AXIS</span>
                            <span class="text-[10px] text-gray-500 font-normal">LOCK</span>
                        </div>
                        <span id="arrow-right" class="arrow-indicator">‚ñ∂</span>
                    </div>
                    <div id="arrow-down" class="arrow-indicator mt-1">‚ñº</div>
                </div>
            </div>

        </div>

        <!-- Footer -->
        <footer class="text-center pointer-events-auto pb-4">
            <div class="inline-block glass-panel px-10 py-3 rounded-full border border-cyan-900 shadow-[0_0_20px_rgba(0,240,255,0.2)]">
                <p class="text-xs font-mono text-cyan-400 tracking-[0.2em] animate-pulse">PINCH & DRAG TO ROTATE // FIST TO EXPLODE</p>
            </div>
        </footer>

    </div>

    <!-- Logic -->
    <script type="module">
        // We use dynamic imports inside initSystem to avoid top-level await/loading issues blocking the UI
        
        // CONFIG
        const CONFIG = {
            particleCount: 3000,
            particleSize: 0.30,
            color: 0x00f0ff,
            camDepth: 35
        };

        const STATE = {
            currentShape: 'sphere',
            handPos: new THREE.Vector3(0, 0, 0),
            prevHandPos: new THREE.Vector3(0, 0, 0),
            isTracking: false,
            gesture: 'IDLE',
            targetPositions: null,
            usingMouse: false
        };

        let scene, camera, renderer, particles, geometry, cursor;
        let originalPositions, currentPositions;
        let handLandmarker;
        let lastVideoTime = -1;

        // --- GLOBAL FUNCTIONS ATTACHED TO WINDOW ---
        
        window.initSystem = async function() {
            const btn = document.querySelector('#init-screen button');
            const statusMsg = document.getElementById('status-msg');
            btn.innerText = "ACCESSING HARDWARE...";
            btn.classList.add('opacity-50', 'cursor-not-allowed');

            try {
                let stream = null;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    const video = document.getElementById("webcam");
                    video.srcObject = stream;
                    await new Promise(resolve => video.addEventListener("loadeddata", resolve));
                } catch (camErr) {
                    console.warn("Camera denied:", camErr);
                    STATE.usingMouse = true;
                }

                if (!STATE.usingMouse) {
                    btn.innerText = "LOADING AI MODELS...";
                    await initVisionModels();
                } else {
                    statusMsg.innerText = "Camera denied. Switching to Manual Override.";
                    await new Promise(r => setTimeout(r, 1000));
                }
                
                initThree();
                
                const screen = document.getElementById('init-screen');
                screen.style.opacity = '0';
                setTimeout(() => screen.remove(), 1000);
                document.getElementById('ui-layer').classList.remove('hidden');
                
                if (STATE.usingMouse) {
                    document.getElementById('cam-status-dot').classList.replace('bg-red-500', 'bg-yellow-500');
                    document.getElementById('cam-status-dot').style.boxShadow = "0 0 10px yellow";
                    document.getElementById('no-cam-icon').classList.remove('hidden');
                    document.getElementById('gesture-desc').innerText = "Mouse Input Active";
                    setupMouseFallback();
                } else {
                    document.getElementById('cam-status-dot').classList.replace('bg-red-500', 'bg-green-500');
                    document.getElementById('cam-status-dot').style.boxShadow = "0 0 10px #00ff00";
                    document.getElementById('cam-status-dot').classList.add('animate-pulse');
                }

            } catch (err) {
                console.error(err);
                btn.innerText = "CRITICAL FAILURE";
                statusMsg.innerText = "Error: " + err.message;
            }
        };

        window.updateParticleSize = function(val) {
            const size = parseFloat(val);
            document.getElementById('size-val').innerText = size.toFixed(2);
            if(particles && particles.material) particles.material.size = size;
        };

        window.updateZoom = function(val) {
            const zoom = parseFloat(val);
            CONFIG.camDepth = zoom;
            document.getElementById('zoom-val').innerText = zoom.toFixed(0);
            if(camera) camera.position.z = zoom;
        };
        
        window.switchShape = function(type, btnElement) {
            STATE.currentShape = type;
            document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
            if(btnElement) btnElement.classList.add('active');

            const targetPos = getShapePositions(type);
            STATE.targetPositions = targetPos; 
            const tweenData = { t: 0 };
            const startPos = Float32Array.from(originalPositions);

            new TWEEN.Tween(tweenData)
                .to({ t: 1 }, 1500)
                .easing(TWEEN.Easing.Exponential.InOut)
                .onUpdate(() => {
                    for(let i=0; i < CONFIG.particleCount; i++) {
                        const idx = i * 3;
                        originalPositions[idx] = startPos[idx] + (targetPos[idx] - startPos[idx]) * tweenData.t;
                        originalPositions[idx+1] = startPos[idx+1] + (targetPos[idx+1] - startPos[idx+1]) * tweenData.t;
                        originalPositions[idx+2] = startPos[idx+2] + (targetPos[idx+2] - startPos[idx+2]) * tweenData.t;
                    }
                })
                .start();
                
            if(type === 'explode') setTimeout(() => window.switchShape('sphere', document.querySelector('nav button')), 2000);
        };

        window.addEventListener('wheel', (e) => {
            let newZoom = CONFIG.camDepth + (e.deltaY * 0.05);
            if (newZoom < 10) newZoom = 10;
            if (newZoom > 100) newZoom = 100;
            CONFIG.camDepth = newZoom;
            if(camera) camera.position.z = newZoom;
            document.getElementById('zoom-slider').value = newZoom;
            document.getElementById('zoom-val').innerText = newZoom.toFixed(0);
        });

        // --- INTERNAL HELPERS ---

        function setupMouseFallback() {
            window.addEventListener('mousemove', (e) => {
                STATE.isTracking = true;
                const nx = (e.clientX / window.innerWidth) * 2 - 1;
                const ny = -(e.clientY / window.innerHeight) * 2 + 1;
                updateHandPosFromScreen(nx, ny);
            });

            window.addEventListener('mousedown', (e) => {
                if(e.button === 0) STATE.gesture = 'PINCH';
                else if (e.button === 2) STATE.gesture = 'FIST';
                updateUI(STATE.gesture);
            });

            window.addEventListener('mouseup', () => {
                STATE.gesture = 'IDLE';
                updateUI(STATE.gesture);
            });
        }

        function updateHandPosFromScreen(ndcX, ndcY) {
            const dist = CONFIG.camDepth; 
            const vFOV = THREE.MathUtils.degToRad(75);
            const height = 2 * Math.tan(vFOV / 2) * dist;
            const width = height * (window.innerWidth / window.innerHeight);
            
            // Update Previous before Current
            STATE.prevHandPos.copy(STATE.handPos);
            
            STATE.handPos.x = ndcX * (width / 2.5);
            STATE.handPos.y = ndcY * (height / 2.5);
            
            if(cursor) {
                cursor.position.copy(STATE.handPos);
                cursor.visible = true;
            }
        }

        // THREE JS
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.camDepth;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<CONFIG.particleCount * 3; i++) positions.push((Math.random() - 0.5) * 100);

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            originalPositions = new Float32Array(positions);

            const sprite = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/spark1.png');
            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                color: CONFIG.color,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            const ringGeo = new THREE.RingGeometry(1.5, 1.8, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            cursor = new THREE.Mesh(ringGeo, ringMat);
            cursor.visible = false;
            scene.add(cursor);

            animate();
            switchShape('sphere', document.querySelector('nav button'));

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // SHAPES
        function getShapePositions(type) {
            const arr = [];
            const count = CONFIG.particleCount;
            if (type === 'sphere') {
                for (let i = 0; i < count; i++) {
                    const phi = Math.acos(-1 + (2 * i) / count);
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    const r = 15;
                    arr.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }
            } else if (type === 'cube') {
                const size = 20;
                for (let i = 0; i < count; i++) arr.push((Math.random()-0.5)*size, (Math.random()-0.5)*size, (Math.random()-0.5)*size);
            } else if (type === 'arc') {
                const R = 12; const r = 3;
                for (let i = 0; i < count; i++) {
                    const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2;
                    arr.push((R+r*Math.cos(v))*Math.cos(u), (R+r*Math.cos(v))*Math.sin(u), r*Math.sin(v));
                }
            } else if (type === 'helix') {
                for (let i = 0; i < count; i++) {
                    const t = i * 0.1; const r = 8;
                    arr.push(r * Math.cos(t), (i * 0.03) - 25, r * Math.sin(t));
                }
            } else if (type === 'explode') {
                for (let i = 0; i < count; i++) arr.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*150);
            }
            return arr;
        }

        // VISION (Dynamic Import)
        async function initVisionModels() {
            // Using dynamic import to prevent top-level await block and ensure module is loaded only when needed
            // Also utilizing +esm to ensure correct module format from CDN
            const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm");
            const { FilesetResolver, HandLandmarker } = vision;
            
            const wasm = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(wasm, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
        }

        function processVision() {
            if (STATE.usingMouse) return;

            const video = document.getElementById("webcam");
            if (video.currentTime !== lastVideoTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());

                if (results.landmarks && results.landmarks.length > 0) {
                    STATE.isTracking = true;
                    const lm = results.landmarks[0];
                    
                    const ndcX = (1 - lm[8].x) * 2 - 1; 
                    const ndcY = -(lm[8].y * 2 - 1);
                    updateHandPosFromScreen(ndcX, ndcY);

                    detectGesture(lm);
                } else {
                    STATE.isTracking = false;
                    cursor.visible = false;
                    updateUI('IDLE');
                }
            }
        }

        function detectGesture(lm) {
            const indexTip = lm[8]; const thumbTip = lm[4];
            const pinkyTip = lm[20]; const pinkyBase = lm[17];
            const indexBase = lm[5];

            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            const isPinkyCurled = pinkyTip.y > pinkyBase.y;
            const isIndexCurled = indexTip.y > indexBase.y;

            if (pinchDist < 0.05) STATE.gesture = 'PINCH';
            else if (isIndexCurled && isPinkyCurled && pinchDist > 0.05) STATE.gesture = 'FIST';
            else STATE.gesture = 'IDLE';
            
            updateUI(STATE.gesture);
        }

        function updateUI(gesture) {
            const icon = document.getElementById('gesture-icon');
            const text = document.getElementById('gesture-text');
            const desc = document.getElementById('gesture-desc');
            const cursorMat = cursor.material;

            if (gesture === 'PINCH') {
                icon.innerText = 'ü§è'; text.innerText = 'ROTATION LOCK';
                text.className = 'text-2xl font-bold font-mono text-yellow-400 animate-pulse';
                desc.innerText = STATE.usingMouse ? 'Drag to Rotate' : 'Move Hand to Rotate';
                cursorMat.color.setHex(0xffff00);
            } else if (gesture === 'FIST') {
                icon.innerText = '‚úä'; text.innerText = 'REPULSOR';
                text.className = 'text-2xl font-bold font-mono text-red-500 animate-pulse';
                desc.innerText = STATE.usingMouse ? 'Right Mouse Hold' : 'Dispersing Field...';
                cursorMat.color.setHex(0xff0000);
            } else {
                icon.innerText = 'üñê'; text.innerText = 'HOVER';
                text.className = 'text-2xl font-bold font-mono text-white';
                desc.innerText = STATE.usingMouse ? 'Move Mouse' : 'Tracking active...';
                cursorMat.color.setHex(0x00f0ff);
            }
        }
        
        function updateRotationUI(dirs) {
            const left = document.getElementById('arrow-left');
            const right = document.getElementById('arrow-right');
            const up = document.getElementById('arrow-up');
            const down = document.getElementById('arrow-down');
            
            left.classList.remove('active'); right.classList.remove('active');
            up.classList.remove('active'); down.classList.remove('active');
            
            if(dirs.includes('left')) left.classList.add('active');
            if(dirs.includes('right')) right.classList.add('active');
            if(dirs.includes('up')) up.classList.add('active');
            if(dirs.includes('down')) down.classList.add('active');
        }

        // ANIMATION LOOP
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            processVision();

            const positions = geometry.attributes.position.array;
            
            // --- ROTATION LOGIC (GRAB & DRAG) ---
            let activeDirs = [];
            
            if (STATE.isTracking) {
                if (STATE.gesture === 'PINCH') {
                    // Calculate Delta from Previous Hand Pos
                    const deltaX = STATE.handPos.x - STATE.prevHandPos.x;
                    const deltaY = STATE.handPos.y - STATE.prevHandPos.y;
                    
                    const sensitivity = 0.05;
                    
                    if (Math.abs(deltaX) > 0.05 || Math.abs(deltaY) > 0.05) {
                        particles.rotation.y += deltaX * sensitivity;
                        particles.rotation.x -= deltaY * sensitivity; // Inverted for natural feel
                        
                        // UI Indicators
                        if (deltaX > 0) activeDirs.push('right');
                        else if (deltaX < 0) activeDirs.push('left');
                        if (deltaY > 0) activeDirs.push('up');
                        else if (deltaY < 0) activeDirs.push('down');
                    }
                } else {
                    // Auto Rotate if Idle
                    if(STATE.gesture === 'IDLE') {
                        particles.rotation.y += 0.00;
                    }
                }
            } else {
                particles.rotation.y += 0.00;
            }
            updateRotationUI(activeDirs);

            // --- PHYSICS ---
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                let tx = originalPositions[ix]; let ty = originalPositions[ix+1]; let tz = originalPositions[ix+2];
                
                let offsetX = 0, offsetY = 0, offsetZ = 0;

                if (STATE.isTracking && STATE.gesture === 'FIST') {
                     let dx = STATE.handPos.x - tx;
                     let dy = STATE.handPos.y - ty;
                     let dz = STATE.handPos.z - tz; 
                     const distSq = dx*dx + dy*dy + dz*dz;
                     const dist = Math.sqrt(distSq);
                     
                     if (dist < 25) {
                        const force = (25 - dist) * 2;
                        offsetX = -dx * force; offsetY = -dy * force; offsetZ = -dz * force;
                     }
                }
                
                if (STATE.gesture === 'IDLE' && STATE.isTracking) {
                     let dx = STATE.handPos.x - tx; let dy = STATE.handPos.y - ty;
                     const dist = Math.sqrt(dx*dx + dy*dy);
                     if(dist < 10) {
                         offsetX += (Math.random()-0.5)*0.5;
                         offsetY += (Math.random()-0.5)*0.5;
                     }
                }

                const targetX = tx - offsetX; const targetY = ty - offsetY; const targetZ = tz - offsetZ;
                positions[ix] += (targetX - positions[ix]) * 0.1;
                positions[ix+1] += (targetY - positions[ix+1]) * 0.1;
                positions[ix+2] += (targetZ - positions[ix+2]) * 0.1;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
